function playCurve_MjR

gui = get(gcf,'userdata');         % references data previously set so it can be passed into this function
handles = gui.handles;

% get stimuli
stimcache = get(gui.stimulus, 'userdata');  % stimcache is struct containing set of randomized stimuli generated by function buildCurve_MjR
if isempty(stimcache)
    warndlg('You need to Generate Stimuli before playing a curve.')
    set(gui.playCurve, 'value', 0);  % change button back to un-poked color
    return
end

% get a fake cal structure
caldata = fake_caldata;
% Left output only
LRenable = [1 0];
exptime = now;


disp('Starting curve...');

%-------------------------------------------------------
% Get curvetype
%-------------------------------------------------------
allcurves = get(gui.curvetype,'string');
curveidx = get(gui.curvetype,'value');
curvetype = allcurves(curveidx,:);

%-------------------------------------------------------
% Set up animal/penetration information & info for header writing
%-------------------------------------------------------
handles.animal.animalNumber = gui.animalNum; % it's written to the struct this way to match with HPCurve_buildOutputDataFileName
handles.expDate = date;
handles.expTime = time;
handles.penetration = gui.penetration;
handles.AP = gui.AP;
handles.ML = gui.ML;
handles.depth = gui.depth;
handles.comments = gui.comments;

handles.TempDataCtrl = 0;    % set to 1 to avoid writing data file
handles.curve.curvetype = curvetype;

%-------------------------------------------------------
% Get data filename info
%-------------------------------------------------------
[curvefile, curvepath] = HPCurve_buildOutputDataFileName(gui.handles, exptime);

%-------------------------------------------------------
% Build stimulus file name (if save stimulus is requested)
%-------------------------------------------------------
if gui.saveStim
    % break down data file name
    [pathstr, dname, ext] = fileparts(curvefile);
    % append "_stim" to the filename
    stimfile = [pathstr filesep dname '_stim' '.mat'];
    handles.stimfile = stimfile;
    
%     handles.curve.stimfile = stimfile;
%     guidata(hObject, handles);
end

%-------------------------------------------------------
% make some local copies of config structs to simplify code
%-------------------------------------------------------
% TDT HW things
indev = gui.handles.indev;
outdev = gui.handles.outdev;
PA5 = {gui.handles.PA5L gui.handles.PA5R};  % these were handles.PA5L etc
zBUS = gui.handles.zBUS;
% calibration, stimulus, recording, & analysis options (thresholds)
stim = handles.stim;
% handles.tdt was updated within the function buildCurve_MjR by incorporating items on the GUI
tdt = handles.tdt;
% we created fake caldata for this struct above:  caldata = handles.caldata;

% will we use analysis and curve?  or override this with the generated
% stimuli?  It looks like it pops up a dialog box and you can manually
% overwrite - we could use the same thing but I've already incorporated it
% into the gui here, so we can simply bypass the dialog box.  What is this,
% the royal We?
analysis = handles.analysis;
curve = handles.curve;

%-------------------------------------------------------
%-------------------------------------------------------
%*************** RUN CURVE ****************************
%-------------------------------------------------------
% for new types of curves, edit the
% HPCurve_buildStimCache() function to generate the
% appropriate stimulus type(s)
%-------------------------------------------------------
%-------------------------------------------------------

% run through the stimuli
if ~isempty(stimcache)
    %-------------------------------------------------------
    % add some information to the curve struct - this is mostly
    % so that the curve information is included when the curve
    % struct is written to the data file header by the
    % HPCurve_playCache function
    %-------------------------------------------------------
    % randomized sequence for stimuli
    curve.trialRandomSequence = stimcache.trialRandomSequence;
    % version code for data file
    curve.dataVersion = HPSearch_init('DATAVERSION');
    
    % change values in curve to match those in stimcache
    if length(stimcache.CarrierFREQ{1}) > 1
        curve.stimtype = 'noise';
    end
    curve.nreps =           str2num(read_ui_str(gui.nReps));
    curve.ITDrange =        [];
    curve.ILDrange =        [];
    curve.ABIrange =        [];
    curve.FREQrange =       stimcache.CarrierFREQ{1};
    curve.BCrange =         [];
    curve.ITDrangestr = 	'';
    curve.ILDrangestr =     '';
    curve.ABIrangestr =     '';
    curve.FREQrangestr =    num2str(stimcache.CarrierFREQ{1});
    curve.BCrangestr =      '';
    curve.nTrials =         stimcache.ntrials;
    curve.TempData =        read_ui_val(gui.TempDataCtrl);
    curve.saveStim =        read_ui_val(gui.saveStim);
    curve.RadVary =         0;
    curve.freezeStim =      stimcache.freezeStim;
    curve.sAMPCTrange =     0;
    curve.sAMFREQrange =    0;
    curve.sAMPCTrangestr =  '0';
    curve.sAMFREQrangestr = '0';
    curve.stimfile = 'NOSE.mat';

    % save stimulus cache as a mat file if saveStim is selected
    if read_ui_val(gui.saveStim)
        disp(['Writing stimulus cache to MAT file ' stimfile])
        save(stimfile, 'stimcache', 'caldata', '-MAT')
    end

    % get the date and time
    time_start = now;
keyboard    
    % Call HPCurve_playCache to play the stimuli and record response
    curvedata = HPCurve_playCache(stimcache, curvefile, ...
        curve, stim, tdt, analysis, caldata, ...
        indev, outdev, PA5, zBUS, ...
        handles.iofunction, ...
        gui.RespAxes, gui.RasterAxes, gui.feedbackText); % was H.RespPlot, H.Rasterplot, handles.FeedbackText
    % get the finish time
    time_end = now;

else
    curvedata = [];
end

%-------------------------------------------------------
% if we have data, then save curve info
%-------------------------------------------------------
if ~isempty(curvedata) && (curvedata.cancelFlag == 0);
    % first, build the curvesettings structure from the various
    % settings structs used in HPSearch
    curvesettings.curve = curve;
    curvesettings.stim = stim;
    curvesettings.tdt = tdt;
    curvesettings.analysis = analysis;
    curvesettings.caldata = caldata;
    % store start and stop times as strings
    curvesettings.time_start = datestr(time_start);
    curvesettings.time_stop = datestr(time_end);

    % remove the stimulus traces from the stimcache and add to
    % curvesettings struct
    curvesettings.stimcache = rmfield(stimcache, 'Sn');

    % extract the file name parts from the filename
    [nullpath, curvename, nullext] = fileparts(curvefile);

    % build the curve settings file path
    curvesettingsfile = fullfile(curvepath, [curvename '.mat']);

    % save the curvesettings struct (has curve information)
    % and the curvedata struct (has curve data spike counts
    % but NO RAW DATA!).
    % IMPORTANT: remember that the data in curve data
    % are already sorted into a [# of test values X # of reps] array
    save(curvesettingsfile, '-MAT', 'curvesettings', 'curvedata');

    %-------------------------------------------------------
    % Plot Curve
    %-------------------------------------------------------
    figure
    errorbar(curvedata.depvars_sort(:, 1)', ...
        mean(curvedata.spike_counts'), ...
        std(curvedata.spike_counts'), 'bo-');
    xlabel(curve.curvetype);
    ylabel('# spikes per stimulus');
    title({curve.curvetype})
    drawnow

    % if not, throw a warning
else
    if curvedata.cancelFlag
        warning('User (you?) cancelled curve data collection.');
    else
        warning('Error in running HPCurve, sorry.  really.  I am.');
    end
end

% save handle info
guidata(hObject, handles);

%-------------------------------------------------------
%re-enable the curve and run buttons
%-------------------------------------------------------
update_ui_str(hObject, 'Run Curve');
set(hObject, 'ForegroundColor', [0.0 0.5 0.0]);
enable_ui(handles.RunButton);
enable_ui(handles.CurveButton);
guidata(hObject, handles);
